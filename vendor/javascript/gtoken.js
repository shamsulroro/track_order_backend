import*as e from"fs";import*as t from"gaxios";import*as s from"jws";import*as i from"path";import*as r from"util";import*as o from"google-p12-pem";var n="default"in e?e.default:e;var a="default"in t?t.default:t;var h="default"in s?s.default:s;var l="default"in i?i.default:i;var c="default"in r?r.default:r;var d="default"in o?o.default:o;var u={};Object.defineProperty(u,"__esModule",{value:true});u.GoogleToken=void 0;const p=n;const k=a;const f=h;const T=l;const y=c;const w=p.readFile?(0,y.promisify)(p.readFile):async()=>{throw new ErrorWithCode("use key rather than keyFile.","MISSING_CREDENTIALS")};const g="https://www.googleapis.com/oauth2/v4/token";const m="https://accounts.google.com/o/oauth2/revoke?token=";class ErrorWithCode extends Error{constructor(e,t){super(e);this.code=t}}let v;class GoogleToken{
/**
   * Create a GoogleToken.
   *
   * @param options  Configuration object.
   */
constructor(e){this.transporter={request:e=>(0,k.request)(e)};this.configure(e)}get accessToken(){return this.rawToken?this.rawToken.access_token:void 0}get idToken(){return this.rawToken?this.rawToken.id_token:void 0}get tokenType(){return this.rawToken?this.rawToken.token_type:void 0}get refreshToken(){return this.rawToken?this.rawToken.refresh_token:void 0}hasExpired(){const e=(new Date).getTime();return!this.rawToken||!this.expiresAt||e>=this.expiresAt}isTokenExpiring(){var e;const t=(new Date).getTime();const s=null!==(e=this.eagerRefreshThresholdMillis)&&void 0!==e?e:0;return!this.rawToken||!this.expiresAt||this.expiresAt<=t+s}getToken(e,t={}){if("object"===typeof e){t=e;e=void 0}t=Object.assign({forceRefresh:false},t);if(!e)return this.getTokenAsync(t);{const s=e;this.getTokenAsync(t).then((e=>s(null,e)),e)}}
/**
   * Given a keyFile, extract the key and client email if available
   * @param keyFile Path to a json, pem, or p12 file that contains the key.
   * @returns an object with privateKey and clientEmail properties
   */async getCredentials(e){const t=T.extname(e);switch(t){case".json":{const t=await w(e,"utf8");const s=JSON.parse(t);const i=s.private_key;const r=s.client_email;if(!i||!r)throw new ErrorWithCode("private_key and client_email are required.","MISSING_CREDENTIALS");return{privateKey:i,clientEmail:r}}case".der":case".crt":case".pem":{const t=await w(e,"utf8");return{privateKey:t}}case".p12":case".pfx":{v||(v=(await Promise.resolve().then((()=>d))).getPem);const t=await v(e);return{privateKey:t}}default:throw new ErrorWithCode("Unknown certificate type. Type is determined based on file extension. Current supported extensions are *.json, *.pem, and *.p12.","UNKNOWN_CERTIFICATE_TYPE")}}async getTokenAsync(e){if(this.inFlightRequest&&!e.forceRefresh)return this.inFlightRequest;try{return await(this.inFlightRequest=this.getTokenAsyncInner(e))}finally{this.inFlightRequest=void 0}}async getTokenAsyncInner(e){if(false===this.isTokenExpiring()&&false===e.forceRefresh)return Promise.resolve(this.rawToken);if(!this.key&&!this.keyFile)throw new Error("No key or keyFile set.");if(!this.key&&this.keyFile){const e=await this.getCredentials(this.keyFile);this.key=e.privateKey;this.iss=e.clientEmail||this.iss;e.clientEmail||this.ensureEmail()}return this.requestToken()}ensureEmail(){if(!this.iss)throw new ErrorWithCode("email is required.","MISSING_CREDENTIALS")}revokeToken(e){if(!e)return this.revokeTokenAsync();this.revokeTokenAsync().then((()=>e()),e)}async revokeTokenAsync(){if(!this.accessToken)throw new Error("No token to revoke.");const e=m+this.accessToken;await this.transporter.request({url:e});this.configure({email:this.iss,sub:this.sub,key:this.key,keyFile:this.keyFile,scope:this.scope,additionalClaims:this.additionalClaims})}
/**
   * Configure the GoogleToken for re-use.
   * @param  {object} options Configuration object.
   */configure(e={}){this.keyFile=e.keyFile;this.key=e.key;this.rawToken=void 0;this.iss=e.email||e.iss;this.sub=e.sub;this.additionalClaims=e.additionalClaims;"object"===typeof e.scope?this.scope=e.scope.join(" "):this.scope=e.scope;this.eagerRefreshThresholdMillis=e.eagerRefreshThresholdMillis;e.transporter&&(this.transporter=e.transporter)}async requestToken(){var e,t;const s=Math.floor((new Date).getTime()/1e3);const i=this.additionalClaims||{};const r=Object.assign({iss:this.iss,scope:this.scope,aud:g,exp:s+3600,iat:s,sub:this.sub},i);const o=f.sign({header:{alg:"RS256"},payload:r,secret:this.key});try{const e=await this.transporter.request({method:"POST",url:g,data:{grant_type:"urn:ietf:params:oauth:grant-type:jwt-bearer",assertion:o},headers:{"Content-Type":"application/x-www-form-urlencoded"},responseType:"json"});this.rawToken=e.data;this.expiresAt=null===e.data.expires_in||void 0===e.data.expires_in?void 0:1e3*(s+e.data.expires_in);return this.rawToken}catch(s){this.rawToken=void 0;this.tokenExpires=void 0;const i=s.response&&(null===(e=s.response)||void 0===e?void 0:e.data)?null===(t=s.response)||void 0===t?void 0:t.data:{};if(i.error){const e=i.error_description?`: ${i.error_description}`:"";s.message=`${i.error}${e}`}throw s}}}u.GoogleToken=GoogleToken;const E=u.__esModule;const _=u.GoogleToken;export{_ as GoogleToken,E as __esModule,u as default};

