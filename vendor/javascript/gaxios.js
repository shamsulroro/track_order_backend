import*as e from"extend";import*as t from"https";import*as r from"node-fetch";import*as n from"querystring";import*as o from"is-stream";import*as a from"url";import s from"./common.js";import*as i from"https-proxy-agent";import u from"process";import f from"buffer";var d={};Object.defineProperty(d,"__esModule",{value:true});d.getRetryConfig=void 0;async function getRetryConfig(e){var t;let r=getConfig(e);if(!e||!e.config||!r&&!e.config.retry)return{shouldRetry:false};r=r||{};r.currentRetryAttempt=r.currentRetryAttempt||0;r.retry=void 0===r.retry||null===r.retry?3:r.retry;r.httpMethodsToRetry=r.httpMethodsToRetry||["GET","HEAD","PUT","OPTIONS","DELETE"];r.noResponseRetries=void 0===r.noResponseRetries||null===r.noResponseRetries?2:r.noResponseRetries;const n=[[100,199],[429,429],[500,599]];r.statusCodesToRetry=r.statusCodesToRetry||n;e.config.retryConfig=r;const o=r.shouldRetry||shouldRetryRequest;if(!await o(e))return{shouldRetry:false,config:e.config};const a=r.currentRetryAttempt?0:null!==(t=r.retryDelay)&&void 0!==t?t:100;const s=a+(Math.pow(2,r.currentRetryAttempt)-1)/2*1e3;e.config.retryConfig.currentRetryAttempt+=1;const i=r.retryBackoff?r.retryBackoff(e,s):new Promise((e=>{setTimeout(e,s)}));r.onRetryAttempt&&r.onRetryAttempt(e);await i;return{shouldRetry:true,config:e.config}}d.getRetryConfig=getRetryConfig;
/**
 * Determine based on config if we should retry the request.
 * @param err The GaxiosError passed to the interceptor.
 */function shouldRetryRequest(e){const t=getConfig(e);if("AbortError"===e.name)return false;if(!t||0===t.retry)return false;if(!e.response&&(t.currentRetryAttempt||0)>=t.noResponseRetries)return false;if(!e.config.method||t.httpMethodsToRetry.indexOf(e.config.method.toUpperCase())<0)return false;if(e.response&&e.response.status){let r=false;for(const[n,o]of t.statusCodesToRetry){const t=e.response.status;if(t>=n&&t<=o){r=true;break}}if(!r)return false}t.currentRetryAttempt=t.currentRetryAttempt||0;return!(t.currentRetryAttempt>=t.retry)}
/**
 * Acquire the raxConfig object from an GaxiosError if available.
 * @param err The Gaxios error with a config object.
 */function getConfig(e){if(e&&e.config&&e.config.retryConfig)return e.config.retryConfig}var c="default"in e?e.default:e;var l="default"in t?t.default:t;var p="default"in r?r.default:r;var y="default"in n?n.default:n;var h="default"in o?o.default:o;var g="default"in a?a.default:a;var m="default"in i?i.default:i;var v={};var R=f.Buffer;var w=u;var x=v&&v.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(v,"__esModule",{value:true});v.Gaxios=void 0;const C=x(c);const b=l;const T=x(p);const _=x(y);const A=x(h);const P=g;const O=s;const q=d;
/* eslint-disable @typescript-eslint/no-explicit-any */const k=hasFetch()?window.fetch:T.default;function hasWindow(){return"undefined"!==typeof window&&!!window}function hasFetch(){return hasWindow()&&!!window.fetch}function hasBuffer(){return"undefined"!==typeof R}function hasHeader(e,t){return!!getHeader(e,t)}function getHeader(e,t){t=t.toLowerCase();for(const r of Object.keys((null===e||void 0===e?void 0:e.headers)||{}))if(t===r.toLowerCase())return e.headers[r]}let G;function loadProxy(){var e,t,r,n;const o=(null===(e=null===w||void 0===w?void 0:w.env)||void 0===e?void 0:e.HTTPS_PROXY)||(null===(t=null===w||void 0===w?void 0:w.env)||void 0===t?void 0:t.https_proxy)||(null===(r=null===w||void 0===w?void 0:w.env)||void 0===r?void 0:r.HTTP_PROXY)||(null===(n=null===w||void 0===w?void 0:w.env)||void 0===n?void 0:n.http_proxy);o&&(G=m);return o}loadProxy();function skipProxy(e){var t;const r=null!==(t=w.env.NO_PROXY)&&void 0!==t?t:w.env.no_proxy;if(!r)return false;const n=r.split(",");const o=new P.URL(e);return!!n.find((e=>{if(e.startsWith("*.")||e.startsWith(".")){e=e.replace(/^\*\./,".");return o.hostname.endsWith(e)}return e===o.origin||e===o.hostname}))}function getProxy(e){return skipProxy(e)?void 0:loadProxy()}class Gaxios$1{
/**
   * The Gaxios class is responsible for making HTTP requests.
   * @param defaults The default set of options to be used for this instance.
   */
constructor(e){this.agentCache=new Map;this.defaults=e||{}}
/**
   * Perform an HTTP request with the given options.
   * @param opts Set of HTTP options that will be used for this HTTP request.
   */async request(e={}){e=this.validateOpts(e);return this._request(e)}async _defaultAdapter(e){const t=e.fetchImplementation||k;const r=await t(e.url,e);const n=await this.getResponseData(e,r);return this.translateResponse(e,r,n)}
/**
   * Internal, retryable version of the `request` method.
   * @param opts Set of HTTP options that will be used for this HTTP request.
   */async _request(e={}){try{let t;t=e.adapter?await e.adapter(e,this._defaultAdapter.bind(this)):await this._defaultAdapter(e);if(!e.validateStatus(t.status)){if("stream"===e.responseType){let e="";await new Promise((r=>{t.data.on("data",(t=>{e+=t}));t.data.on("end",r)}));t.data=e}throw new O.GaxiosError(`Request failed with status code ${t.status}`,e,t)}return t}catch(t){const r=t;r.config=e;const{shouldRetry:n,config:o}=await(0,q.getRetryConfig)(r);if(n&&o){r.config.retryConfig.currentRetryAttempt=o.retryConfig.currentRetryAttempt;return this._request(r.config)}throw r}}async getResponseData(e,t){switch(e.responseType){case"stream":return t.body;case"json":{let e=await t.text();try{e=JSON.parse(e)}catch(e){}return e}case"arraybuffer":return t.arrayBuffer();case"blob":return t.blob();default:return t.text()}}
/**
   * Validates the options, and merges them with defaults.
   * @param opts The original options passed from the client.
   */validateOpts(e){const t=(0,C.default)(true,{},this.defaults,e);if(!t.url)throw new Error("URL is required.");const r=t.baseUrl||t.baseURL;r&&(t.url=r+t.url);t.paramsSerializer=t.paramsSerializer||this.paramsSerializer;if(t.params&&Object.keys(t.params).length>0){let e=t.paramsSerializer(t.params);e.startsWith("?")&&(e=e.slice(1));const r=t.url.includes("?")?"&":"?";t.url=t.url+r+e}"number"===typeof e.maxContentLength&&(t.size=e.maxContentLength);"number"===typeof e.maxRedirects&&(t.follow=e.maxRedirects);t.headers=t.headers||{};if(t.data){const e="undefined"!==typeof FormData&&(null===t||void 0===t?void 0:t.data)instanceof FormData;if(A.default.readable(t.data))t.body=t.data;else if(hasBuffer()&&R.isBuffer(t.data)){t.body=t.data;hasHeader(t,"Content-Type")||(t.headers["Content-Type"]="application/json")}else if("object"===typeof t.data){if(!e)if("application/x-www-form-urlencoded"===getHeader(t,"content-type"))t.body=t.paramsSerializer(t.data);else{hasHeader(t,"Content-Type")||(t.headers["Content-Type"]="application/json");t.body=JSON.stringify(t.data)}}else t.body=t.data}t.validateStatus=t.validateStatus||this.validateStatus;t.responseType=t.responseType||"json";t.headers.Accept||"json"!==t.responseType||(t.headers.Accept="application/json");t.method=t.method||"GET";const n=getProxy(t.url);if(n)if(this.agentCache.has(n))t.agent=this.agentCache.get(n);else{if(t.cert&&t.key){const e=new P.URL(n);t.agent=new G({port:e.port,host:e.host,protocol:e.protocol,cert:t.cert,key:t.key})}else t.agent=new G(n);this.agentCache.set(n,t.agent)}else if(t.cert&&t.key)if(this.agentCache.has(t.key))t.agent=this.agentCache.get(t.key);else{t.agent=new b.Agent({cert:t.cert,key:t.key});this.agentCache.set(t.key,t.agent)}return t}
/**
   * By default, throw for any non-2xx status code
   * @param status status code from the HTTP response
   */validateStatus(e){return e>=200&&e<300}
/**
   * Encode a set of key/value pars into a querystring format (?foo=bar&baz=boo)
   * @param params key value pars to encode
   */paramsSerializer(e){return _.default.stringify(e)}translateResponse(e,t,r){const n={};t.headers.forEach(((e,t)=>{n[t]=e}));return{config:e,data:r,headers:n,status:t.status,statusText:t.statusText,request:{responseURL:t.url}}}}v.Gaxios=Gaxios$1;var j={};Object.defineProperty(j,"__esModule",{value:true});j.request=j.instance=j.Gaxios=j.GaxiosError=void 0;const S=v;Object.defineProperty(j,"Gaxios",{enumerable:true,get:function(){return S.Gaxios}});var E=s;Object.defineProperty(j,"GaxiosError",{enumerable:true,get:function(){return E.GaxiosError}});j.instance=new S.Gaxios;
/**
 * Make an HTTP request using the given options.
 * @param opts Options for the request
 */async function request(e){return j.instance.request(e)}j.request=request;const L=j.__esModule,M=j.instance,H=j.Gaxios,D=j.GaxiosError;const U=j.request;export{H as Gaxios,D as GaxiosError,L as __esModule,j as default,M as instance,U as request};

